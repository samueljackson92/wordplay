package uk.ac.aber.dcs.slj11.wordplay.datastruct;

import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map.Entry;
import java.util.PriorityQueue;
import java.util.Stack;

import uk.ac.aber.dcs.slj11.wordplay.datastruct.graph.AbstractGraph;
import uk.ac.aber.dcs.slj11.wordplay.datastruct.graph.Node;
import uk.ac.aber.dcs.slj11.wordplay.util.WordLadderComparator;

/**
 * Data structure to represent the graph of a set of words of the same length.
 * @author Samuel Jackson (slj11@aber.ac.uk)
 *
 */
public class WordLadderGraph extends AbstractGraph<String> {
	
	/**
	 * Path variable used to hold the path generated by the search algorithm
	 */
	private Stack<String> path;
	
	/**
	 * Generates a new graph object given a list of strings.
	 * @param words The list of words to use for generation.
	 */
	public void makeGraph(LinkedList<String> words) {
		//make nodes on graph
		for (String word : words) {
			addNode(word);
			getNode(word).setKey(word);
		}
	
		//make the edges between nodes
		Iterator<Entry<String,Node<String>>> it = getIterator();
		while(it.hasNext()) {
			String word = it.next().getKey();
			LinkedList<String> neighbours = findNeighbours(word);
			setNeighbours(word, neighbours);
		}
	}
	
	/**
	 * Generate a new word ladder given a starting word and a number of steps.
	 * Uses a depth-limited search, where the number of steps acts as the limit.
	 * @param word The starting word
	 * @param steps The number of steps to generate
	 * @return LinkedList of strings specifying the path
	 */
	public Stack<String> generate(String word, int steps) {
		
		path = new Stack<String>();
		
		//begin depth limited search to generate to 
		//the given number of steps
		boolean result = depthLimitedSearch(word, 0, steps);
		
		//if solution found, add the initial word to the stack
		if (result) {
			path.push(word);
			
		//return empty path if we didn't reach the desired steps
		} else if(path.size() < steps) {
			path.clear();
		} 
		
		resetGraph();
		
		return path;
		
	}

	/**
	 * Generate a path from one word to another. 
	 * Uses iterative deepening depth-limited search.
	 * @param start The word to start generating from
	 * @param finish The target word to reach
	 * @return LinkedList of strings specifying the path
	 */
	public Stack<String> discovery(String start, String finish) {
		path = new Stack<String>();
		boolean result = aStarSearch(start, finish);
		
		if(!result) {
			path.clear();
		}
		
		resetGraph();
		return path;
	}
	
	/**
	 * Implementation of depth-limited search algorithm. Used by generation mode to find a long path through the tree.
	 * @param word The current node being looked at
	 * @param currentDepth The current depth in the graph
	 * @param maxDepth The maximum depth to descend before quitting the search
	 * @return whether the search was successful or not.
	 */
	private boolean depthLimitedSearch(String word, int currentDepth, int maxDepth) {
		boolean result = false;
		
		//check if this node has been visited
		//if not, mark it
		if(!nodeIsVisited(word)) {
			setNodeVisited(word);
		}
			
		//If we've reached the max depth then quit searching
		if(currentDepth >= maxDepth-1) {
			result = true;
			
		//else begin searching neighbour nodes for solution
		} else {
			Iterator<String> neighbours = getNeighbors(word).iterator();
			
			//traverse through neighbours
			//exit early if we get a solution
			while (neighbours.hasNext() && !result) {
				String s = neighbours.next();

				//check if this child has been visited
				if(!nodeIsVisited(s)) {
					
					//run search on all given nodes
					result = depthLimitedSearch(s, (currentDepth+1), maxDepth);
					if(result){
						path.push(s);
					}
				}
			}
		}
		
		return result;
	}
	
	/**
	 * Implementation of an A* search algorithm. Used by discovery mode to find the shortest path between two nodes.
	 * Uses Hamming distance as the heuristic path cost function.
	 * @param start The node to start from
	 * @param goal The node to search for.
	 * @return whether the search was successful or not.
	 */
	private boolean aStarSearch(String start, String goal) {
		boolean result = false;
		PriorityQueue<Node<String>> frontier = new PriorityQueue<Node<String>>(10, new WordLadderComparator());
		
		//hashtable to store links to the previous nodes in path
		Hashtable<String, String> previous = new Hashtable<String, String>();
		
		//add start to frontier
		frontier.offer(getNode(start));
		
		//set initial path cost and path cost estimate
		setPathCost(start, 0);
		setPathCostEstimate(start, 0 + hammingDistance(start, goal));
		
		//run search while there are still nodes in the frontier
		//and a solution has not been found.
		while (!frontier.isEmpty() && !result) {
			//remove node with lowest estimate path cost
			String node = frontier.remove().getKey();
			
			//check if this node is the goal
			if(node.equals(goal)) {
				result = true;
			
			//else continue search child nodes
			} else {
				for(String child : getNeighbors(node)){
					int tentativepathcost = getPathCost(node) + 1;
					
					//check if node has been visited,
					//or if already marked for exploration
					//or if it may still offer a shorter path.
					if((!nodeIsVisited(child) || tentativepathcost <= getPathCost(child)
							|| getPathCost(child) < 0) && !frontier.contains(child)) {
						
						setNodeVisited(child);
						//set path cost and estimate path length
						setPathCost(child, tentativepathcost);
						setPathCostEstimate(child, tentativepathcost + hammingDistance(child, goal));
						
						frontier.offer(getNode(child)); //add child to frontier
						previous.put(child, node); //record a link from this node back to it's parent
					}
				}
			}
		}
		
		//if search was successful, 
		//build path from goal to solution
		if(result) {
			path.push(goal);
			
			String current = goal;
			while(!current.equals(start)){
				current = previous.get(current);
				path.push(current);
			}
		}
		
		return result;
	}
	
	/**
	 * Find all of a given words neighbours in the graph
	 * @param word Key of the desired node
	 * @return LinkedList of string representing the words neighbours
	 */
	private LinkedList<String> findNeighbours(String word) {
		LinkedList<String> found = new LinkedList<String>();
		Iterator<Entry<String,Node<String>>> it = getIterator();
		
		//Iterate over the hashtable
		while(it.hasNext()) {
			//get the key
			String next = it.next().getKey();
			
			//check if there is only one letter difference
			if(isAdjacent(word, next)) {
				found.add(next);
			}
		}
		
		return found;
	}
	
	/**
	 * Check is the given words are only letter in difference
	 * @param word1 First word to compare
	 * @param word2 Second word to compare
	 * @return Whether they are one letter different or not.
	 */
	private boolean isAdjacent(String word1, String word2) {
		//if > 1 then the nodes are too different
		return (hammingDistance(word1, word2) == 1);
	}
	
	/**
	 * Finds the difference between two strings of equal length.
	 * @param word1 first string to be compared
	 * @param word2 second string to be compared
	 * @return the difference between two strings
	 */
	private int hammingDistance(String word1, String word2) {
		int count = 0;

		//loop over each char in both strings
		for(int i=0; i<word1.length();i++) {
			if (word1.charAt(i) != word2.charAt(i)) {
				//count how many are unequal
				count++;
			}
		}
		return count;
	}
}